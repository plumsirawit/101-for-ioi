\chapter{Divide and Conquer}

\section{Van Emde Boas Tree Analysis}

ในปี 1975 ทีมของนักวิทยาศาสตร์คอมพิวเตอร์ นำโดยชาวดัตช์คนหนึ่ง ชื่อของเขาคือ Peter van Emde Boas เขาได้ทำการออกแบบโครงสร้างข้อมูลชนิดหนึ่งขึ้นมา ปัจจุบันนี้มีชื่อเรียกว่า van Emde Boas tree

โดยต้นไม้ชนิดนี้ สามารถทำหน้าที่ได้เทียบเท่าโครงสร้างข้อมูลประเภทตารางค้นหา (lookup table) แต่ในที่นี้เราจะพูดถึงรูปแบบที่ใช้ทำหน้าที่เก็บข้อมูลประเภทเซตของจำนวนเต็มไม่ลบขนาด $m$ บิต (ข้อมูลมีค่าระหว่าง $0$ ถึง $2^m-1$)

สำหรับในข้อนี้ เราจะไม่อธิบายขั้นตอนวิธีการทำงานของโครงสร้างข้อมูล van Emde Boas tree เนื่องจากเป็นเนื้อหานอกขอบเขต (จะอยู่ในขอบเขตค่ายถัดไป) อย่างไรก็ตาม เป้าหมายของข้อนี้คือการพิสูจน์ Time Complexity ของการทำงานบน van Emde Boas tree ในแต่ละครั้ง

\begin{exercise}
กำหนดให้ $R \colon \N \to \R$ นิยามโดย $R(1) = R(0) = 1$ และ 
\[
R(n) = R\left(\left\lfloor\frac{n}{2}\right\rfloor\right) + O(1)
\]
สำหรับ $n \in \N - \{0, 1\}$ ใด จงแสดงว่า $R(n) \in O(\log n)$
\end{exercise}

กำหนดให้ $T \colon \R \to \R$ โดย $T(x) = 0$ สำหรับทุกจำนวนจริง $x < 1$ และ $T(1) = 1$

ต้นไม้ van Emde Boas ที่สามารถเก็บจำนวนเต็มได้ตั้งแต่ $0$ ถึง $M-1$ เมื่อ $M$ เป็นผลยกกำลังของสอง (กล่าวคือ $M = 2^m$ สำหรับบาง $m \in \N$) จะใช้ระยะเวลาในการดำเนินการหนึ่งครั้งในเวลา $T(M)$ เมื่อ
\[
T(x) = T(\sqrt{x}) + O(1)
\]
สำหรับจำนวนจริง $x > 1$ ใด ๆ

\begin{exercise}
จงพิสูจน์ว่า $S(m) \in O(\log m)$ เมื่อ $S \colon \R \to \R$ เป็นฟังก์ชันนิยามโดย $S(x) := T(2^x)$
\end{exercise}

\begin{exercise}
จงพิสูจน์ว่า $T(M) \in O(\log \log M)$
\end{exercise}

\section{Centroid Decomposition of a Tree}

พิจารณาต้นไม้ที่ประกอบด้วยจุดยอด $N$ จุดยอด (มีเส้นเชื่อม $N-1$ เส้นเชื่อมตามนิยามของต้นไม้)

\begin{exercise}
จงพิสูจน์ว่ามีจุดยอดอย่างน้อยหนึ่งจุด ที่เมื่อตัดจุดยอดนี้ออกไปแล้วจะแบ่งต้นไม้ออกเป็น $k$ ส่วน โดยที่ต้นไม้ย่อยแต่ละส่วนจากทั้ง $k$ ส่วน จะมีจำนวนจุดยอดในต้นไม่้ย่อยนั้นไม่เกิน $\frac{N}{2}$
\end{exercise}

เราทำการสร้างต้นไม้ใหม่อีกต้น เรียกว่า Centroid Tree โดยมีวิธีการสร้างดังนี้:

\begin{enumerate}[nosep]
    \item จากต้นไม้ต้นปัจจุบัน ให้ $c$ เป็น centroid ของต้นไม้นี้
    \item ตัด $c$ ออกจากต้นไม้ปัจจุบัน ทำให้ต้นไม้หลักแบ่งออกเป็น $k$ ต้นไม้ย่อย หลังจากนั้นทำการหา centroid ของต้นไม้ย่อยแต่ละต้น เรียกเป็น $c_1, c_2, \dots, c_k$
    \item ทำการเชื่อมเส้นเชื่อมบน Centroid Tree โดยสร้างเส้นเชื่อม $(c, c_1), (c, c_2), \dots, (c, c_k)$ และกำหนดให้ $c$ เป็น parent ของ $c_1, c_2, \dots, c_k$ ใน Centroid Tree
    \item ย้อนกลับไปทำข้อ 1. โดยเปลี่ยนต้นไม้ปัจจุบันเป็นต้นไม้ย่อยแต่ละต้นที่ถูกตัดออกจาก $c$
\end{enumerate}

โดยให้ centroid เริ่มแรกเป็นรากของ Centroid Tree

\begin{exercise}
จงพิสูจน์ว่าความสูงของ Centroid Tree อยู่ใน $O(\log N)$
\end{exercise}

นอกจากนี้ โดยปกติการทำการค้นหาแนวลึก (Depth-first search) บนต้นไม้ จะใช้เวลา $O(N)$ โดยคิดเวลาดังนี้
\[
T(t_i) = \sum_{u \in C(t_i)} T(t_u) + O(1)
\]
เมื่อ $t_i$ แทนต้นไม้ย่อยที่มีรากอยู่ที่ $i$ และ $C(x)$ แทนเซตของลูก (children) ของจุดยอด $x$

การทำงานของการค้นหาแนวลึกข้างต้นใช้เวลา $O(N)$ อย่างไรก็ตาม หากเราต้องการค้นหาทั้งต้นไม้ย่อยในแต่ละครั้ง ดังนี้
\[
T(t_i) = \sum_{u \in C(t_i)} T(t_u) + O(|t_i|)
\]
เมื่อ $|t_i|$ แทนขนาดของต้นไม้ย่อยที่มีรากอยู่ที่ $i$ อาจให้เวลาการทำงานเฉลี่ยน $O(N^2)$ สำหรับต้นไม้อื่น ๆ ทั่วไป

\begin{exercise}
จงพิสูจน์ว่าการทำงานของอัลกอริทึมข้างต้น ทำในเวลา $O(N \log N)$ สำหรับ Centroid Tree
\end{exercise}

\section{Ternary Search}

พิจารณาอัลกอริทึมที่แก้ปัญหาค่าสูงสุดสำหรับฟังก์ชันที่มีสมบัติว่า มีค่า $m$ ที่สำหรับทุก $x, y$ ถ้า $x < y \leq m$ แล้ว $f(x) < f(y) \leq f(m)$ และถ้า $m \geq x > y$ แล้ว $f(m) \geq f(x) > f(y)$

โดยอัลกอริทึมทำงานดังนี้:
\begin{enumerate}[nosep]
    \item แบ่งช่วงที่ต้องการค้นหาออกเป็นสามส่วน คือช่วงซ้าย ช่วงกลาง และช่วงขวา อย่างเท่า ๆ กัน โดยแบ่งที่จุด $L$ และจุด $R$ และสมมติขอบเขตล่างคือ $A$ ขอบเขตบนคือ $B$ (จะได้ช่วง $[A, L), (L, R), (R, B]$)
    \item หาก $f(L) < f(R)$ ลดขอบเขตลงเหลือเพียง $[L, B]$
    \item หาก $f(L) > f(R)$ ลดขอบเขตลงเหลือเพียง $[A, R]$
    \item หาก $f(L) = f(R)$ ลดขอบเขตลงเหลือเพียง $[L, R]$
    \item ทำซำ้จนกว่าจะได้ค่าที่ละเอียดเพียงพอ
\end{enumerate}

ลองพิจารณาในกรณีที่ฟังก์ชันรับเฉพาะจำนวนเต็มเท่านั้น และรับในช่วง $[1, N]$ เท่านั้น

\begin{exercise}
จงเขียน Recurrence เพื่อคำนวณระยะเวลาที่อัลกอริทึมนี้ใช้ในการทำงาน
\end{exercise}

\begin{exercise}
จงพิสูจน์ว่าอัลกอริทึมนี้ใช้เวลา $O(\log N)$
\end{exercise}

\section{Hidden Gems}

มีหลุมอยู่ $N$ หลุม เรียงกันเป็นเส้นตรง เรียกหลุมที่ $1$ ถึงหลุมที่ $N$ มีอัญมณีซ่อนอยู่ $K$ ชิ้นภายในหลุมทั้ง $N$ หลุม ไม่มีอัญมณีสองชิ้นใด ๆ อยู่ในหลุมเดียวกันเลย คุณสามารถเลือกเซตย่อยของ $\{1, \dots, N\}$ แล้วส่งไปถามว่าภายในหลุมที่มีหมายเลขอยู่ในเซตนี้ มีอัญมณีอยู่กี่ชิ้น

\begin{exercise}
สำหรับกรณี $K = 1$ จงออกแบบอัลกอริทึมในการแก้ปัญหานี้โดยการถามจำนวน $O(\log N)$ ครั้ง
\end{exercise}

\begin{exercise}
สำหรับกรณีทั่วไป จงออกแบบอัลกอริทึมในการแก้ปัญหานี้โดยการถาม $O(K \log N)$ ครั้ง
\end{exercise}

\begin{bonus}
หากยอมให้อัญมณีอยู่ในหลุมซำ้กันได้จะเกิดอะไรขึ้น ยังมีอัลกอริทึมที่มีประสิทธิภาพที่ตอบปัญหานี้ได้อยู่หรือไม่?
\end{bonus}