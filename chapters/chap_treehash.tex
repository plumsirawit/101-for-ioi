\chapter{Tree \& Hash}

\section{Fenwick Tree}

ในปี 1994 นั้น Peter M. Fenwick ได้ออกแบบโครงสร้างข้อมูลที่มีชื่อว่า Binary Indexed Tree หรือที่เราเรียกกันว่า Fenwick Tree ในงานเขียนชื่อว่า ``A new data structure for cumulative frequency tables''

สำหรับการ implement โครงสร้างนี้ระหว่างเขียนโปรแกรมเชิงการแข่งขันในภาษา C++ หลายคนนิยมใช้วิธีดังต่อไปนี้

\begin{lstlisting}
int FT[M];
int lsb(int n){
    return n & -n;
}
void add(int idx, int amt){
    while(idx < M){
        FT[idx] += amt;
        idx += lsb(idx);
    }
}
int sum(int idx){
    int ret = 0;
    while(idx > 0){
        ret += FT[idx];
        idx -= lsb(idx);
    }
    return ret;
}
\end{lstlisting}

\begin{exercise}
สำหรับจำนวนเต็มบวก $n \in \N_{\texttt{int}}$ ใด ๆ เมื่อ $\N_{\texttt{int}}$ แทนเซตของจำนวนเต็มระหว่าง $0$ ถึง $2^{32}-1$ จงแสดงว่าหากเขียน $n$ ในรูป
\[
n = \sum_{n=0}^{31} b_i 2^i
\]
เมื่อ $b_i \in \{0, 1\}$ สำหรับ $i \in \{0, \dots, 31\}$ แล้ว \texttt{lsb(n)} จะมีค่าเท่ากับ $2^{\min\{i \in \{0, \dots, 31\} \colon b_i = 1\}}$
\end{exercise}

ให้ $M$ เป็นจำนวนเต็มที่ $10 \leq M \leq 2\,000\,000$

\begin{exercise}
จงพิสูจน์ว่า สำหรับ $n \in \N$ ใด ๆ ที่ $0 \leq n < M$ การเรียกใช้ฟังก์ชัน \texttt{sum(n)} จะไปพิจารณาค่าใน \texttt{FT} เพียง $O(\log M)$ ค่าเท่านั้น (คำใบ้: พิจารณาฟังก์ชัน $\phi \colon \N_{\texttt{int}} \to \N$ นิยามโดย สำหรับจำนวนเต็มบวก $n \in \N_{\texttt{int}}$ ใด ๆ หากเขียน $n$ ในรูป
\[
n = \sum_{n=0}^{31} b_i 2^i
\]
เมื่อ $b_i \in \{0, 1\}$ สำหรับ $i \in \{0, \dots, 31\}$ แล้ว นิยามให้ $\phi(n) = |\{i \in \{0, \dots, 31\} \colon b_i = 1\}|$ แล้วสังเกตค่าของ $\phi(n)$)
\end{exercise}

หากรับประกันว่าค่าที่ใส่ลงไปในฟังก์ชัน \texttt{add} แต่ละครั้งไม่มีครั้งใดติดลบ เราจะได้เงื่อนไขพิเศษว่า \texttt{sum(n)} มีค่ามากกว่าหรือเท่ากับศูนย์เสมอ สำหรับทุก $0 \leq n < M$

\begin{exercise}
จงพิสูจน์ข้อความข้างต้น
\end{exercise}

\begin{exercise}
กำหนดค่า $k$ ให้มา หากต้องการหาค่าของจำนวนเต็ม $n$ ที่น้อยที่สุดที่ \texttt{sum(n)} มีค่ามากกว่าหรือเท่ากับ $k$ จงออกแบบอัลกอริทึมที่ทำงานดังกล่าวได้อย่างมีประสิทธิภาพ (เป้าหมายคือ $O(\log M)$)
\end{exercise}

\section{Hashed Set}

โดยทั่วไป เราไม่สามารถประกาศใช้ \texttt{std::unordered\_set<std::set<int>>} ได้ เพราะโครงสร้างข้อมูล \texttt{std::set<int>} นั้นไม่นิยามแฮชฟังก์ชัน อย่างไรก็ตามหากเซตของเรานั้นเป็นเซตทางคณิตศาสตร์ที่มีสมาชิกคงที่ ไม่มีการใส่เข้าหรือลบออก มันก็ยังเป็นไปได้ที่จะออกแบบตารางแฮชสำหรับเซตเหล่านี้

\begin{exercise}
จงออกแบบแฮชฟังก์ชัน $h \colon \mathcal{P}(\N_{\texttt{int}}) \to \N$ เมื่อ $\N_{\texttt{int}}$ แทนเซตของจำนวนเต็มระหว่าง $0$ ถึง $2^{32}-1$ ที่มีประสิทธิภาพ และอธิบายว่าฟังก์ชันที่ออกแบบนี้ดีอย่างไร
\end{exercise}

\section{Merge Sort tree}

ปกติแล้ว เราสามารถใช้ Segment tree หรือ Interval tree ในการตอบคำถามประเภท Range Minimum Query (RMQ) คือ มีอาเรย์ของจำนวนเต็มใน $\N_{\texttt{int}}$ ประกอบด้วยจำนวนเต็ม $N$ ตัว เรียกว่า $A$ และจะเขียน $A_i$ แทนจำนวนเต็มในช่องที่ $i$ ของอาเรย์ สำหรับ $i \in \{0, \dots, N-1\}$ แล้วมีคำถามต่อมาอีก $Q$ คำถาม แต่ละคำถามจะให้ค่า $(l, r) \in \{0, \dots, N-1\}^2$ มา จงหาว่าค่าต่ำสุดในช่วงจากช่องที่ $l$ ถึงช่องที่ $r$ เป็นเท่าใด กล่าวคือ ให้หาค่าของ $\min\{A_i \colon i \in [l, r] \cap \N\}$

เรารู้ว่าโครงสร้างอย่าง Segment tree หรือ Interval tree สามารถตอบคำถามดังกล่าวได้ในเวลา $O(\log N)$ อย่างไรก็ตาม ในข้อนี้เราจะพูดถึงคำถามอีกประเภทที่จะต้องใช้โครงสร้างข้อมูลที่ดัดแปลงมากจากต้นไม้เหล่านั้น

\textbf{โจทย์} มีอาเรย์ของจำนวนเต็มใน $\N_{\texttt{int}}$ ประกอบด้วยจำนวนเต็ม $N$ ตัว เรียกว่า $A$ และจะเขียน $A_i$ แทนจำนวนเต็มในช่องที่ $i$ ของอาเรย์ สำหรับ $i \in \{0, \dots, N-1\}$ แล้วมีคำถามต่อมาอีก $Q$ คำถาม แต่ละคำถามจะให้ค่า $(l, r, x) \in \{0, \dots, N-1\}^2 \times \N_{\texttt{int}}$ มา ให้หาว่าในช่วงระหว่างช่องที่ $l$ ถึงช่องที่ $r$ นั้นมีค่าอยู่กี่ตัวที่ไม่เกิน $x$ กล่าวคือ ให้หาค่าของ $|\{A_i \colon i \in [l, r] \cap \N \text{ และ } A_i \leq x\}|$

\begin{exercise}
มีวิธีการในตอบคำถามในโจทย์ข้างต้นโดยทำการเตรียมการ (preprocess) ใน $O(N \log N)$ ใช้หน่วยความจำใน $O(N \log N)$ และตอบคำถามใน $O(\log^2 N)$ หรือไม่ หากมี จงอธิบายและพิสูจน์ว่าทำได้ตามเป้าหมายทุกอย่าง
\end{exercise}

พิจารณาปัญหาต่อมา โดยโจทย์มีดังนี้

\textbf{โจทย์} มีอาเรย์ของจำนวนเต็มใน $\N_{\texttt{int}}$ ประกอบด้วยจำนวนเต็ม $N$ ตัว เรียกว่า $A$ และจะเขียน $A_i$ แทนจำนวนเต็มในช่องที่ $i$ ของอาเรย์ สำหรับ $i \in \{0, \dots, N-1\}$ แล้วมีคำถามต่อมาอีก $Q$ คำถาม แต่ละคำถามจะให้ค่า $(l, r, c) \in \{0, \dots, N-1\}^3$ มา และรับประกันว่า $c$ มีค่าไม่เกิน $|r-l|$ ให้หาว่าในช่วงระหว่างช่องที่ $l$ ถึงช่องที่ $r$ หากนำมาเรียงจากน้อยไปมากแล้ว ตัวที่ $c$ จากน้อยไปมาก (เริ่มนับจาก $0$ ถึง $r-l$) จะมีค่าเท่ากับเท่าไร

\begin{exercise}
จงออกแบบอัลกอริทึม/โครงสร้างข้อมูลที่ทำตามโจทย์ข้างต้นโดยทำการเตรียมการใน $O(N \log N)$ ใช้หน่วยความจำใน $O(N \log N)$ และตอบคำถามข้างต้นได้ใน $O(\log^3 N)$
\end{exercise}

\begin{bonus}
มีวิธีที่ตอบคำถามได้เร็วกว่า $O(\log^3 N)$ หรือไม่?
\end{bonus}

\section{Prime Probing}

\begin{exercise}
สำหรับตารางแฮชบรรจุจำนวนเต็มไม่ลบขนาด $10$ ซึ่งนับเป็นช่องตั้งแต่ช่องที่ $0$ ถึงช่องที่ $9$ เราจะมีอัลกอริทึมการใส่ของในตารางแฮชแบบ Prime Probing ดังนี้

สำหรับการใส่จำนวนเต็มไม่ลบ $n$ ลงไปในตารางแฮช ให้ $r$ เป็นเลขหลักหน่วยของ $n$ หลังจากนั้นพิจารณาช่อง $r$ ของตาราง สำหรับ $i = 1, 2, 3, \dots$ หากในช่องที่ $r$ นั้นมีของอยู่ ให้ปรับ $r$ กลายเป็นเลขหลักหน่วยของ $(r+p_i)$ แล้วทำไปเรื่อย ๆ จนกว่าช่อง $r$ จะว่าง แล้วจึงนำ $n$ ใส่ลงในช่อง $r$ เมื่อ $p_i$ แทนจำนวนเฉพาะตัวที่ $i$ ($p_1 = 2; p_2 = 3; \dots$)

จงเขียนผลลัพธ์ของตารางแฮชหลังดำเนินการแต่ละอย่างต่อไปนี้ (ทีละอย่าง)

\begin{enumerate}[nosep,label={\bfseries (\roman*)}]
    \item ใส่ $42$
    \item ใส่ $69$
    \item ใส่ $112$
    \item ใส่ $116$
    \item ใส่ $44$
    \item ใส่ $2022$
\end{enumerate}
\end{exercise}

\begin{exercise}
ระหว่างวิธีการจัดการ Hash collision แบบ Probing กับแบบใช้โครงสร้างข้อมูลภายในซ้อนลงไป สอบแบบนี้ต่างกันอย่างไร และมีข้อดีข้อเสียอย่างไร?
\end{exercise}